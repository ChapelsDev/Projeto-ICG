<!DOCTYPE html>
<html>
<head>
    <title>Three.js Game</title>
	<style>
        body { margin: 0; }
		#score {
			position: absolute;
			top: 10px;
			left: 10px;
			font-size: 100px;
			font-weight: bold;
			color: white;
			z-index: 10;
			padding: 15px 20px; /* Increased padding for a more spacious look */
			border-radius: 10px; /* Larger border-radius for softer corners */
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Gradient background */
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
			box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2); /* Add a drop shadow */
			transition: transform 0.3s ease-out; /* Simplified transition */
		}
		
		#score:hover {
			transform: scale(1.1); /* Slightly smaller scale for hover */
		}

		.score-update {
			transform: scale(1.1) translateY(-5px); /* Example animation */
		}
		#texture-buttons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

		.texture-button {
			display: inline-block; /* or inline-flex for more layout control */
			padding: 10px 15px;
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Light gray background */
			border: 1px solid #ccc; /* Subtle border */
			border-radius: 5px;
			margin-right: 10px;
			font-size: 20px;
			font-weight: bold;
			color: white;
			cursor: pointer;
			transition: all 0.2s ease; /* Smooth transitions */
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow */
		}
		
		.texture-button:hover {
			font-size: 20px;
			font-weight: bold;
			color: white;
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Slightly darker on hover */
			transform: translateY(-2px); /* Lift on hover */
			box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.2); /* More prominent shadow on hover */
		}
    </style>
</head>
<body>
	<div id="score">0</div> 
	<div id="texture-buttons"></div>
	<script src = build/cannon.min.js></script>
	<script src = build/cannon.js></script> 
    <script type="module">
		
		import * as THREE from 'https://threejs.org/build/three.module.js';		
		
		window.focus(); // Capture keys right away (by default focus is on editor)
		
		let camera, scene, renderer;
		let world;
		let lastTime;
		let stack;
		let overhangs;
		const boxHeight = 1;
		const originalBoxSize = 3;
		let gameEnded;
		const scoreElement = document.getElementById("score");
		const instructionsElement = document.getElementById("instructions");
		const resultsElement = document.getElementById("results");

		const textureLoader = new THREE.TextureLoader();
        const textures = [
            { icon: 'ðŸŸ«BRICK', texture: textureLoader.load('medieval_red_brick_diff_1k.jpg') },  // Replace with your image paths
            { icon: 'ðŸŸ¦WOOD', texture: textureLoader.load('rosewood_veneer1_diff_1k.jpg') },
            { icon: 'ðŸŸ©EARTH', texture: textureLoader.load('coast_sand_rocks_02_diff_1k.jpg') }
        ];

        let currentTextureIndex = 0; // Start with the first texture

        init();
        createTextureButtons();

		function init() {
		gameEnded = false;
		lastTime = 0;
		stack = [];
		overhangs = [];

		world = new CANNON.World();
		world.gravity.set(0, -10, 0);
		world.broadphase = new CANNON.NaiveBroadphase();
		world.solver.iterations = 40;

		const scoreElement = document.getElementById("score");

		const aspect = window.innerWidth / window.innerHeight;
		const width = 10;
		const height = width / aspect;

		camera = new THREE.OrthographicCamera(
			width / -2, width / 2,
			height / 2, height / -2,
			0, 100
		);
		camera.position.set(4, 4, 4);
		camera.lookAt(0, 0, 0);

		scene = new THREE.Scene();

		// Foundation
		addLayer(0, 0, originalBoxSize, originalBoxSize);

		// First layer
		addLayer(-10, 0, originalBoxSize, originalBoxSize, "x");

		const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
		scene.add(ambientLight);

		const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
		dirLight.position.set(10, 20, 0);
		scene.add(dirLight);

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.setAnimationLoop(animation);
		document.body.appendChild(renderer.domElement);
		}

		function addLayer(x, z, width, depth, direction) {
		const y = boxHeight * stack.length;
		const layer = generateBox(x, y, z, width, depth, false);
		layer.direction = direction;
		stack.push(layer);
		}

		function applyTextureToBlocks() {
            const newMaterial = new THREE.MeshLambertMaterial({ map: textures[currentTextureIndex].texture });
            stack.forEach(layer => layer.threejs.material = newMaterial);
            overhangs.forEach(overhang => overhang.threejs.material = newMaterial);
        }

		function createTextureButtons() {
            const textureButtonsContainer = document.getElementById('texture-buttons');
            textures.forEach((texture, index) => {
                const button = document.createElement('span');
                button.classList.add('texture-button');
                button.textContent = texture.icon; // Use emoji for now, replace with images later
                button.addEventListener('click', () => {
                    currentTextureIndex = index; 
                    applyTextureToBlocks();
                });
                textureButtonsContainer.appendChild(button);
            });
        }


		function addOverhang(x, z, width, depth) {
		const y = boxHeight * (stack.length - 1);
		const overhang = generateBox(x, y, z, width, depth, true);
		overhangs.push(overhang);
		}

		function generateBox(x, y, z, width, depth, falls) {
		const geometry = new THREE.BoxGeometry(width, boxHeight, depth);
		const material = new THREE.MeshLambertMaterial({ map: textures[currentTextureIndex].texture }); // Use the current texture
		const mesh = new THREE.Mesh(geometry, material);
		mesh.position.set(x, y, z);
		scene.add(mesh);

		const shape = new CANNON.Box(new CANNON.Vec3(width / 2, boxHeight / 2, depth / 2));
		let mass = falls ? 5 : 0;
		mass *= width / originalBoxSize;
		mass *= depth / originalBoxSize;
		const body = new CANNON.Body({ mass, shape });
		body.position.set(x, y, z);
		world.addBody(body);

		return {
			threejs: mesh,
			cannonjs: body,
			width,
			depth
		};
		}

		function cutBox(topLayer, overlap, size, delta) {
		const direction = topLayer.direction;
		const newWidth = direction == "x" ? overlap : topLayer.width;
		const newDepth = direction == "z" ? overlap : topLayer.depth;

		topLayer.width = newWidth;
		topLayer.depth = newDepth;

		topLayer.threejs.scale[direction] = overlap / size;
		topLayer.threejs.position[direction] -= delta / 2;

		topLayer.cannonjs.position[direction] -= delta / 2;

		const shape = new CANNON.Box(new CANNON.Vec3(newWidth / 2, boxHeight / 2, newDepth / 2));
		topLayer.cannonjs.shapes = [];
		topLayer.cannonjs.addShape(shape);
		}

		window.addEventListener("mousedown", eventHandler);
		window.addEventListener("touchstart", eventHandler);
		window.addEventListener("keydown", function (event) {
			if (event.key == " ") {
			  event.preventDefault();
			  eventHandler();
			  return;
			}
			if (event.key == "R" || event.key == "r") {
			  event.preventDefault();
			  startGame();
			  return;
			}
		  });
		  
		  function startGame() {
			gameEnded = false;
			lastTime = 0;
			stack = [];
			overhangs = [];
			scoreElement.innerText = 0; // Reset the score
		  
			if (instructionsElement) instructionsElement.style.display = "none";
			if (resultsElement) resultsElement.style.display = "none";
			if (scoreElement) scoreElement.innerText = 0;
		  
			if (world) {
			  while (world.bodies.length > 0) {
				world.remove(world.bodies[0]);
			  }
			}
		  
			if (scene) {
			  while (scene.children.find((c) => c.type == "Mesh")) {
				const mesh = scene.children.find((c) => c.type == "Mesh");
				scene.remove(mesh);
			  }
			  addLayer(0, 0, originalBoxSize, originalBoxSize);
			  addLayer(-10, 0, originalBoxSize, originalBoxSize, "x");
			}

			// Keep track of the last selected texture
			const lastTextureIndex = currentTextureIndex;

			// Re-apply the last selected texture after reset
			currentTextureIndex = lastTextureIndex;
			applyTextureToBlocks(); 
		  
			if (camera) {
			  camera.position.set(4, 4, 4);
			  camera.lookAt(0, 0, 0);
			}
		  }
		  

		function eventHandler() {
		splitBlockAndAddNextOneIfOverlaps();
		}

		function splitBlockAndAddNextOneIfOverlaps() {
		if (gameEnded) return;

		const topLayer = stack[stack.length - 1];
		const previousLayer = stack[stack.length - 2];

		const direction = topLayer.direction;
		const size = direction == "x" ? topLayer.width : topLayer.depth;
		const delta = topLayer.threejs.position[direction] - previousLayer.threejs.position[direction];
		const overhangSize = Math.abs(delta);
		const overlap = size - overhangSize;

		if (overlap > 0) {
			cutBox(topLayer, overlap, size, delta);

			const overhangShift = (overlap / 2 + overhangSize / 2) * Math.sign(delta);
			const overhangX = direction == "x" ? topLayer.threejs.position.x + overhangShift : topLayer.threejs.position.x;
			const overhangZ = direction == "z" ? topLayer.threejs.position.z + overhangShift : topLayer.threejs.position.z;
			const overhangWidth = direction == "x" ? overhangSize : topLayer.width;
			const overhangDepth = direction == "z" ? overhangSize : topLayer.depth;

			addOverhang(overhangX, overhangZ, overhangWidth, overhangDepth);

			const nextX = direction == "x" ? topLayer.threejs.position.x : -10;
			const nextZ = direction == "z" ? topLayer.threejs.position.z : -10;
			const newWidth = topLayer.width;
			const newDepth = topLayer.depth;
			const nextDirection = direction == "x" ? "z" : "x";

			let currentScore = parseInt(scoreElement.innerText);
			scoreElement.innerText = ++currentScore;

			// Award bonus points for perfect placement
			if (overlap === size) { // Perfect placement (no overhang)
				currentScore += 5; // Add 5 bonus points (adjust as desired)
			} else if (currentScore % 10 === 0) { // Milestone bonus
				currentScore += 10; // Add 10 bonus points every 10 points (adjust as desired)
			}
			

			// Use a CSS class to trigger the transition
			scoreElement.classList.add('score-update'); 

			setTimeout(() => {
				scoreElement.innerText = currentScore;
				scoreElement.classList.remove('score-update');
			}, 300)
		
			if (scoreElement) scoreElement.innerText = stack.length - 1;
			addLayer(nextX, nextZ, newWidth, newDepth, nextDirection);
		} else {
			missedTheSpot();
		}
		}

		function missedTheSpot() {
		const topLayer = stack[stack.length - 1];

		addOverhang(
			topLayer.threejs.position.x,
			topLayer.threejs.position.z,
			topLayer.width,
			topLayer.depth
		);
		world.remove(topLayer.cannonjs);
		scene.remove(topLayer.threejs);

		gameEnded = true;
		if (resultsElement) resultsElement.style.display = "flex";
		}

		function animation(time) {
		if (lastTime) {
			const timePassed = time - lastTime;
			const speed = 0.008;

			const topLayer = stack[stack.length - 1];
			const previousLayer = stack[stack.length - 2];

			const boxShouldMove = !gameEnded;

			if (boxShouldMove) {
			topLayer.threejs.position[topLayer.direction] += speed * timePassed;
			topLayer.cannonjs.position[topLayer.direction] += speed * timePassed;

			if (topLayer.threejs.position[topLayer.direction] > 10) {
				missedTheSpot();
			}
			}

			if (camera.position.y < boxHeight * (stack.length - 2) + 4) {
			camera.position.y += speed * timePassed;
			}

			updatePhysics(timePassed);
			renderer.render(scene, camera);
		}
		lastTime = time;
		}

		function updatePhysics(timePassed) {
		world.step(timePassed / 1000);

		overhangs.forEach((element) => {
			element.threejs.position.copy(element.cannonjs.position);
			element.threejs.quaternion.copy(element.cannonjs.quaternion);
		});
		}

		window.addEventListener("resize", () => {
		const aspect = window.innerWidth / window.innerHeight;
		const width = 10;
		const height = width / aspect;

		camera.top = height / 2;
		camera.bottom = height / -2;

		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.render(scene, camera);
		});
    </script>
    <!-- Include any other dependencies here -->
    <!-- Then include your main.js script -->
    <script type="module-shim" src="main.js"></script>
</body>
</html>