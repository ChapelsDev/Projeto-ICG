<!DOCTYPE html>
<html>
<head>
    <title>Three.js Game</title>
	<style>
        body { margin: 0; }
		#score {
			position: absolute;
			top: 10px;
			left: 10px;
			font-size: 100px;
			font-weight: bold;
			color: white;
			z-index: 10;
			padding: 15px 20px; /* Increased padding for a more spacious look */
			border-radius: 10px; /* Larger border-radius for softer corners */
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Gradient background */
			text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); /* More pronounced shadow */
			box-shadow: 0px 4px 6px rgba(0, 0, 0, 0.2); /* Add a drop shadow */
			transition: transform 0.3s ease-out; /* Simplified transition */
		}
		
		#score:hover {
			transform: scale(1.1); /* Slightly smaller scale for hover */
		}

		.score-update {
			transform: scale(1.1) translateY(-5px); /* Example animation */
		}
		#texture-buttons {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 10;
        }

		.texture-button {
			display: inline-block; /* or inline-flex for more layout control */
			padding: 10px 15px;
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Light gray background */
			border: 1px solid #ccc; /* Subtle border */
			border-radius: 5px;
			margin-right: 10px;
			font-size: 20px;
			font-weight: bold;
			color: white;
			cursor: pointer;
			transition: all 0.2s ease; /* Smooth transitions */
			box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1); /* Subtle shadow */
		}
		
		.texture-button:hover {
			font-size: 20px;
			font-weight: bold;
			color: white;
			background: linear-gradient(to bottom, #ff0000, #ffce09); /* Slightly darker on hover */
			transform: translateY(-2px); /* Lift on hover */
			box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.2); /* More prominent shadow on hover */
		}
		#game-over {
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent background */
			display: flex; /* Use flexbox for centering */
			text-align: center;
			align-items: center;
			justify-content: center;
			z-index: 11; /* Ensure it's above other elements */
			font-size: 50px; /* Adjust as needed */
			margin-bottom: 20px;
			color: rgb(108, 29, 29);
			font-weight: bold;
			text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000; /* Add a subtle glow/outline effect */
		}

		#restart-message { 
			color: rgb(108, 29, 29);          /* Text color */
			font-size: 24px;       /* Adjust font size as needed */
			font-weight: bold;     /* Make it bold for emphasis */
			text-align: center;   
			margin-top: 20px;     /* Add spacing above the message */
			text-shadow:           /* Add a subtle glow/outline effect */
				-1px -1px 0 #000,  
				1px -1px 0 #000,
				-1px 1px 0 #000,
				1px 1px 0 #000;
		}
		
		/* Optional: Add a subtle animation to the restart message */
		#restart-message {
			animation: blink 1s infinite; /* Blinking animation (you can customize this) */
		}
		
		@keyframes blink {
			0% { opacity: 1; }
			50% { opacity: 0.5; }
			100% { opacity: 1; }
		}
		
		
    </style>
</head>
<body>
	<div id="score">0</div> 
	<div id="texture-buttons"></div>
	<div id="game-over" style="display: none;">
        <h2>Game Over!</h2>
		<p id="restart-message">Press R to restart</p>			 
	</div>
	<script src = build/cannon.min.js></script>
	<script src = build/cannon.js></script> 
	<script type="importmap">
        {
            "imports": {
                "three": "https://threejs.org/build/three.module.js",
                "GLTFLoader": "https://unpkg.com/three@0.158.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>
    <script type="module">
		
		import * as THREE from 'three';
		import { GLTFLoader } from 'GLTFLoader';

		
		
		window.focus(); // Capture keys right away (by default focus is on editor)
		
		let camera, scene, renderer;
		let world;
		let lastTime;
		let stack;
		let overhangs;
		const boxHeight = 1;
		const originalBoxSize = 3;
		let gameEnded;
		const scoreElement = document.getElementById("score");
		const instructionsElement = document.getElementById("instructions");
		const resultsElement = document.getElementById("results");

		const textureLoader = new THREE.TextureLoader();
        const textures = [
            { icon: 'ðŸŸ«BRICK', texture: textureLoader.load('medieval_red_brick_diff_1k.jpg') },  // Replace with your image paths
            { icon: 'ðŸŸ¦WOOD', texture: textureLoader.load('rosewood_veneer1_diff_1k.jpg') },
            { icon: 'ðŸŸ©EARTH', texture: textureLoader.load('coast_sand_rocks_02_diff_1k.jpg') }
        ];

		const altitudeThresholds = [5, 15]; // Change background at these heights

		const sceneWidth = 10;
		const sceneHeight = sceneWidth * (window.innerHeight / window.innerWidth);
		// Initial background plane setup (smaller to start)
		const backgroundPlaneGeometry = new THREE.PlaneGeometry(1, 1); 
		const backgroundPlaneMaterial = new THREE.MeshBasicMaterial({
			map: generateBackgroundTexture(0)
		});
		const backgroundPlane = new THREE.Mesh(backgroundPlaneGeometry, backgroundPlaneMaterial);
		let backgroundTexture = generateBackgroundTexture(0);
		let canvas = backgroundTexture.image; // Get the canvas from the texture
		let starPositions = []; // Array to store initial star positions
		let currentTextureIndex = 0; // Default texture index
		let currentTime = 0; // Track time for animations
		let cloudPositions = [];
		let lastCloudAltitude = 0; // New variable to track the last altitude when clouds were updated
		const cloudUpdateInterval = 500; // Update every 500 milliseconds (adjust as needed)
		let lastCloudUpdate = 0; // Track the last cloud update time
		const maxClouds = 15
		let freezeClouds = false; // Flag to control cloud freezing
		let starTexture;
		let starField = null; // Variable to hold the star field object
		let field = null; // Initialize the field variable to null in the global scope
		let fieldWidth = 100; // Declare fieldWidth in the global scope
		let fieldDepth = 100; // Declare fieldDepth in the global scope

		const gameOverScreen = document.getElementById('game-over');
		// Get reference to the final score element
		const finalScoreValue = document.getElementById('score-value');		




        init();
        createTextureButtons();





		function init() {
			gameEnded = false;
			lastTime = 0;
			stack = [];
			overhangs = [];

			world = new CANNON.World();
			world.gravity.set(0, -10, 0);
			world.broadphase = new CANNON.NaiveBroadphase();
			world.solver.iterations = 40;

			const scoreElement = document.getElementById("score");

			const aspect = window.innerWidth / window.innerHeight;
			const width = 10;
			const height = width / aspect;
			camera = new THREE.OrthographicCamera(
				width / -2, width / 2,
				height / 2, height / -2,
				0, 100
			);
			camera.position.set(4, 4, 4);
			camera.lookAt(0, 0, 0);

			//backgroundPlane.position.set(0, -1, -1);  // Behind the other objects


			backgroundPlane.renderOrder = -1;

			// Make sure the plane faces the camera
			backgroundPlane.lookAt(camera.position);

			scene = new THREE.Scene();

			// Foundation
			addLayer(0, 0, originalBoxSize, originalBoxSize);

			// Green field underneath the foundation block (fixed at y = 0, rotated)
			const fieldGeometry = new THREE.PlaneGeometry(fieldWidth, fieldDepth);
			const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 }); 
			field = new THREE.Mesh(fieldGeometry, fieldMaterial); 
			field.rotation.x = -Math.PI / 2;
		
			// Add grass texture to the field
			const grassTexture = textureLoader.load('grass.jpg');
			grassTexture.wrapS = THREE.RepeatWrapping;
			grassTexture.wrapT = THREE.RepeatWrapping;
			grassTexture.repeat.set(10, 10); 
			field.material.map = grassTexture;
		
		
			scene.add(field); // Add the field (with trees) to the scene
			
			// First layer
			addLayer(-10, 0, originalBoxSize, originalBoxSize, "x");

			// Ambient light (reduced intensity)
			const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // Softer ambient light
			scene.add(ambientLight);

			// Directional light (main light source)
			const dirLight = new THREE.DirectionalLight(0xfff4e5, 0.8);
			dirLight.position.set(10, 20, 10); // Positioned to the upper right
			dirLight.castShadow = true;
			scene.add(dirLight);

			// Additional directional light (for fill/backlight)
			const dirLight2 = new THREE.DirectionalLight(0xfff4e5, 0.8); // Lower intensity
			dirLight2.position.set(-5, 10, -5); // Positioned to the upper left
			scene.add(dirLight2);

			// Point light (for more focused lighting)
			const pointLight = new THREE.PointLight(0xffaa00, 1, 20); // Warm color, intensity 1, distance 20
			pointLight.position.set(0, 5, 0); 
			scene.add(pointLight);


			renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setAnimationLoop(animation);
			document.body.appendChild(renderer.domElement);


			scene.add(backgroundPlane);

			//const boxHelper = new THREE.BoxHelper(backgroundPlane, 0xffff00); // Yellow color
			//scene.add(boxHelper);	

			//const cameraHelper = new THREE.CameraHelper(camera);
			//scene.add(cameraHelper);

		}

		function addLayer(x, z, width, depth, direction) {
		const y = boxHeight * stack.length;
		const layer = generateBox(x, y, z, width, depth, false);
		layer.direction = direction;
		stack.push(layer);
		}

		function createTextureButtons() {
			const textureButtonsContainer = document.getElementById('texture-buttons');
			textures.forEach((texture, index) => {
				const button = document.createElement('div'); // Changed from span to div for more styling flexibility
				button.classList.add('texture-button');
				button.innerHTML = texture.icon;  // Use the icon property instead of textContent
		
				// Add an optional image preview within the button (you can customize this)
				// const img = document.createElement('img');
				// img.src = texture.texture.image.src; // Get the image source from the Three.js texture object
				// img.style.width = '32px'; // Set image size as desired
				// img.style.height = '32px';
				// button.appendChild(img); // Add the image to the button
		
				button.addEventListener('click', () => {
					currentTextureIndex = index;
					applyTextureToBlocks();
				});
				textureButtonsContainer.appendChild(button);
			});
		}
	  
		// Function to show the game over screen
		function showGameOverScreen() {
			gameOverScreen.style.display = 'block';
			// Update the final score value
			if (finalScoreValue) {
				finalScoreValue.innerText = scoreElement.innerText;
			}
			// Animate the opacity
			let opacity = 0;
			const fadeInInterval = setInterval(() => {
				opacity += 0.05;
				gameOverScreen.style.opacity = opacity;
				if (opacity >= 1) {
					clearInterval(fadeInInterval);
				}
			}, 50);
		}


		function applyTextureToBlocks() {
		const newMaterial = new THREE.MeshLambertMaterial({
			map: textures[currentTextureIndex].texture 
		});
		stack.forEach(layer => layer.threejs.material = newMaterial);
		overhangs.forEach(overhang => overhang.threejs.material = newMaterial);
		}

		function addOverhang(x, z, width, depth) {
		const y = boxHeight * (stack.length - 1);
		const overhang = generateBox(x, y, z, width, depth, true);
		overhangs.push(overhang);
		}

		function generateBox(x, y, z, width, depth, falls) {
		const geometry = new THREE.BoxGeometry(width, boxHeight, depth);
		const material = new THREE.MeshLambertMaterial({ map: textures[currentTextureIndex].texture }); // Use the current texture
		const mesh = new THREE.Mesh(geometry, material);
		mesh.position.set(x, y, z);
		scene.add(mesh);

		const shape = new CANNON.Box(new CANNON.Vec3(width / 2, boxHeight / 2, depth / 2));
		let mass = falls ? 5 : 0;
		mass *= width / originalBoxSize;
		mass *= depth / originalBoxSize;
		const body = new CANNON.Body({ mass, shape });
		body.position.set(x, y, z);
		world.addBody(body);

		return {
			threejs: mesh,
			cannonjs: body,
			width,
			depth
		};
		}

		function cutBox(topLayer, overlap, size, delta) {
		const direction = topLayer.direction;
		const newWidth = direction == "x" ? overlap : topLayer.width;
		const newDepth = direction == "z" ? overlap : topLayer.depth;

		topLayer.width = newWidth;
		topLayer.depth = newDepth;

		topLayer.threejs.scale[direction] = overlap / size;
		topLayer.threejs.position[direction] -= delta / 2;

		topLayer.cannonjs.position[direction] -= delta / 2;

		const shape = new CANNON.Box(new CANNON.Vec3(newWidth / 2, boxHeight / 2, newDepth / 2));
		topLayer.cannonjs.shapes = [];
		topLayer.cannonjs.addShape(shape);
		}

		window.addEventListener("mousedown", eventHandler);
		window.addEventListener("touchstart", eventHandler);
		window.addEventListener("keydown", function (event) {
			if (event.key == " ") {
			  event.preventDefault();
			  eventHandler();
			  return;
			}
			if (event.key == "R" || event.key == "r") {
			  event.preventDefault();
			  startGame();
			  return;
			}
		  });
		  
		  function startGame() {
			gameEnded = false;
			lastTime = 0;
			stack = [];
			overhangs = [];
			scoreElement.innerText = 0; // Reset the score
			//reset game over screen
			gameOverScreen.style.display = 'none';
			gameOverScreen.style.opacity = 0; 
		  
			if (instructionsElement) instructionsElement.style.display = "none";
			if (resultsElement) resultsElement.style.display = "none";
			if (scoreElement) scoreElement.innerText = 0;
		  
			if (world) {
			  while (world.bodies.length > 0) {
				world.remove(world.bodies[0]);
			  }
			}

			// Reset background plane
			const initialPlaneGeometry = new THREE.PlaneGeometry(1, 1); 
			const backgroundPlaneMaterial = new THREE.MeshBasicMaterial({
				map: generateBackgroundTexture(0)
			});
			backgroundPlane.geometry.dispose(); // Dispose of the old geometry
			backgroundPlane.geometry = initialPlaneGeometry;
			backgroundPlane.material.needsUpdate = true; // Mark the material for update
			backgroundPlane.position.set(0, 0, -5); // Reset position
			
			// Reset background plane
			backgroundPlane.geometry.dispose();
			backgroundPlane.geometry = new THREE.PlaneGeometry(sceneWidth, sceneHeight);
			backgroundPlane.material.map = generateBackgroundTexture(0); // Reset to initial background
			backgroundPlane.material.needsUpdate = true;
			backgroundPlane.position.set(0, sceneHeight / 2, -5); // Adjust position
			
		  
			if (scene) {
			  while (scene.children.find((c) => c.type == "Mesh")) {
				const mesh = scene.children.find((c) => c.type == "Mesh");
				scene.remove(mesh);
			  }
			  addLayer(0, 0, originalBoxSize, originalBoxSize);
				// Green field underneath the foundation block (fixed at y = 0, rotated)
				const fieldGeometry = new THREE.PlaneGeometry(fieldWidth, fieldDepth);
				const fieldMaterial = new THREE.MeshLambertMaterial({ color: 0x00ff00 }); 
				field = new THREE.Mesh(fieldGeometry, fieldMaterial); 
				field.rotation.x = -Math.PI / 2;
			
				// Add grass texture to the field
				const grassTexture = textureLoader.load('grass.jpg');
				grassTexture.wrapS = THREE.RepeatWrapping;
				grassTexture.wrapT = THREE.RepeatWrapping;
				grassTexture.repeat.set(10, 10); 
				field.material.map = grassTexture;
		
		
				scene.add(field); // Add the field (with trees) to the scene
			  addLayer(-10, 0, originalBoxSize, originalBoxSize, "x");
			}


			// Keep track of the last selected texture
			const lastTextureIndex = currentTextureIndex;

			// Re-apply the last selected texture after reset
			currentTextureIndex = lastTextureIndex;
			applyTextureToBlocks(); 
		  
			if (camera) {
			  camera.position.set(4, 4, 4);
			  camera.lookAt(0, 0, 0);
			}
			if (scene && backgroundPlane) {  
				scene.add(backgroundPlane);
			}
		  }
		  

		function eventHandler() {
		splitBlockAndAddNextOneIfOverlaps();
		}

		function splitBlockAndAddNextOneIfOverlaps() {
		if (gameEnded) return;

		const topLayer = stack[stack.length - 1];
		const previousLayer = stack[stack.length - 2];

		const direction = topLayer.direction;
		const size = direction == "x" ? topLayer.width : topLayer.depth;
		const delta = topLayer.threejs.position[direction] - previousLayer.threejs.position[direction];
		const overhangSize = Math.abs(delta);
		const overlap = size - overhangSize;

		if (overlap > 0) {
			cutBox(topLayer, overlap, size, delta);

			const overhangShift = (overlap / 2 + overhangSize / 2) * Math.sign(delta);
			const overhangX = direction == "x" ? topLayer.threejs.position.x + overhangShift : topLayer.threejs.position.x;
			const overhangZ = direction == "z" ? topLayer.threejs.position.z + overhangShift : topLayer.threejs.position.z;
			const overhangWidth = direction == "x" ? overhangSize : topLayer.width;
			const overhangDepth = direction == "z" ? overhangSize : topLayer.depth;

			addOverhang(overhangX, overhangZ, overhangWidth, overhangDepth);

			const nextX = direction == "x" ? topLayer.threejs.position.x : -10;
			const nextZ = direction == "z" ? topLayer.threejs.position.z : -10;
			const newWidth = topLayer.width;
			const newDepth = topLayer.depth;
			const nextDirection = direction == "x" ? "z" : "x";

			let currentScore = parseInt(scoreElement.innerText);
			scoreElement.innerText = ++currentScore;

			// Award bonus points for perfect placement
			if (overlap === size) { // Perfect placement (no overhang)
				currentScore += 5; // Add 5 bonus points (adjust as desired)
			} else if (currentScore % 10 === 0) { // Milestone bonus
				currentScore += 10; // Add 10 bonus points every 10 points (adjust as desired)
			}
			

			// Use a CSS class to trigger the transition
			scoreElement.classList.add('score-update'); 

			setTimeout(() => {
				scoreElement.innerText = currentScore;
				scoreElement.classList.remove('score-update');
			}, 300)
		
			if (scoreElement) scoreElement.innerText = stack.length - 1;
			addLayer(nextX, nextZ, newWidth, newDepth, nextDirection);
		} else {
			missedTheSpot();
		}
		}

		function missedTheSpot() {
		const topLayer = stack[stack.length - 1];

		addOverhang(
			topLayer.threejs.position.x,
			topLayer.threejs.position.z,
			topLayer.width,
			topLayer.depth
		);
		world.remove(topLayer.cannonjs);
		scene.remove(topLayer.threejs);

		gameEnded = true;
		if (resultsElement) resultsElement.style.display = "flex";
   		showGameOverScreen(); // Show the game over screen
		}

		function initializeStarPositions(altitude) {
			const numStars = Math.min(1000, Math.floor(altitude * 30));
			for (let i = 0; i < numStars; i++) {
				starPositions.push({
					x: Math.random() * 512, 
					y: Math.random() * 512,
				});
			}
		}	

		function initializeCloudPositions(altitude) {
			const numClouds = Math.min(10, Math.floor(altitude * 0.5)); // Adjust density as needed
			for (let i = 0; i < numClouds; i++) {
				cloudPositions.push({
					x: Math.random() * 512,
					y: Math.random() * 200 + 50, 
					size: Math.random() * 30 + 10,
					opacity: Math.random() * 0.5 + 0.3,
					speedX: (Math.random() - 0.5) * 0.2,
					speedY: (Math.random() - 0.5) * 0.1
				});
			}
		}
		

		  function generateBackgroundTexture(altitude) {
			const canvas = document.createElement('canvas');
			canvas.width = 512;
			canvas.height = 512;
			const context = canvas.getContext('2d');
		
			// Define the gradient colors for the transition 
			const colors = [
				{ color: '#000000', stop: 0.35},
				{ color: '#000000', stop: 0.35 },   // Black (starting color)
				{ color: '#0D1E56', stop: 0.5 }, // Black (repeated to make the transition slower)
				{ color: '#87CEEB', stop: 0.75}, // Light blue (starting color)									 
				{ color: '#87CEEB', stop: 1 }    // Light blue (ending color)
			];
		
			// Create a linear gradient 
			const gradient = context.createLinearGradient(0, 0, 0, canvas.height);
		
			// Add color stops based on the altitude
			colors.forEach(colorInfo => {
				gradient.addColorStop(colorInfo.stop, colorInfo.color);
			});
		
			// Fill the canvas with the gradient
			context.fillStyle = gradient;
			context.fillRect(0, 0, canvas.width, canvas.height);

			// Clouds (only visible within a specific altitude range)
			// Clouds (only visible within a specific altitude range)
			if (altitude >= 5 && altitude <= 25) {
				if (cloudPositions.length === 0) { 
					initializeCloudPositions(altitude);
				} 
				
				// If altitude reached 20, freeze the clouds
				if (altitude >= 25 && !freezeClouds) {
					freezeClouds = true; // Set the flag to true
				}
		
				// Add new clouds only if not frozen and after the update interval
				if (!freezeClouds && currentTime - lastCloudUpdate > cloudUpdateInterval && cloudPositions.length < maxClouds) {
					const newCloud = {
						x: -100 - Math.random() * 200, // Start off-screen to the left
						y: Math.random() * 50 + 100,
						size: Math.random() * 50 + 30,
						opacity: Math.random() * 0.5 + 0.3,
						speedX: Math.random() * 0.2 + 0.1 // Random horizontal speed
					};
					cloudPositions.push(newCloud);
					lastCloudUpdate = currentTime; // Update the last update time
				}
		
				context.save();
				for (let i = 0; i < cloudPositions.length; i++) {
					const cloud = cloudPositions[i];
					const { x, y, size, opacity } = cloudPositions[i];
		
					// Draw a simple cloud shape
					context.beginPath();
					context.arc(x, y, size, 0, Math.PI * 2, false);
					context.arc(x + size, y, size * 0.8, 0, Math.PI * 2, false);
					context.arc(x - size * 0.5, y, size * 0.6, 0, Math.PI * 2, false);
					context.closePath();
					context.fillStyle = `rgba(255, 255, 255, ${opacity})`;
					context.fill();
					// Move clouds only if they are not frozen
					if (!freezeClouds) {
						cloud.x += cloud.speedX; // Use the correct speedX property
					}
				}
				context.restore();
			}
		
		
			 // Stars (only visible after reaching black background)
			 if (altitude >= 23) {
				let blinkFactor = Math.sin(currentTime * 0.001) * 0.2 + 0.4; 
		
				if (starPositions.length === 0) {
					initializeStarPositions(altitude);
				}
		
				// Draw stars over the gradient
				context.save();
				context.globalCompositeOperation = 'lighter';
		
				for (let i = 0; i < starPositions.length; i++) {
					const { x, y } = starPositions[i];
					// Calculate starBrightness inside the loop
					const starBrightness = Math.max(0, blinkFactor); // Adjusted star brightness calculation
					const starSize = 1;
		
					// Radial gradient for softer edges
					const gradient = context.createRadialGradient(x, y, 0, x, y, starSize);
					gradient.addColorStop(0, `rgba(255, 255, 255, ${starBrightness})`);
					gradient.addColorStop(1, `rgba(255, 255, 255, 0)`);
		
					context.fillStyle = gradient;
					context.fillRect(x, y, starSize, starSize);
				}
		
				context.restore();
			}
		
			return new THREE.CanvasTexture(canvas);
		  }

		function replaceClouds(numCloudsToReplace) {
			const numClouds = cloudPositions.length;
			for (let i = 0; i < numCloudsToReplace; i++) {
				// Randomly select a cloud to replace
				const cloudIndex = Math.floor(Math.random() * numClouds);
		
				// Replace the cloud properties with new random values
				cloudPositions[cloudIndex].x = Math.random() * 512;
				cloudPositions[cloudIndex].y = Math.random() * 200 + 50;
				cloudPositions[cloudIndex].size = Math.random() * 5 + 5;
				cloudPositions[cloudIndex].opacity = Math.random() * 0.5 + 0.3;
				cloudPositions[cloudIndex].speedX = (Math.random() - 0.5) * 0.2;
				cloudPositions[cloudIndex].speedY = (Math.random() - 0.5) * 0.1;
			}
		}
		
		// Helper function for color interpolation
		function lerpColor(startColor, endColor, alpha) {
			const start = hexToRgb(startColor);
			const end = hexToRgb(endColor);
			const r = Math.round(start.r + (end.r - start.r) * alpha);
			const g = Math.round(start.g + (end.g - start.g) * alpha);
			const b = Math.round(start.b + (end.b - start.b) * alpha);
			return `rgb(${r}, ${g}, ${b})`;
		}
		
		
		// Helper function to convert hex color to RGB
		function hexToRgb(hex) {
			const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
			return result ? {
				r: parseInt(result[1], 16),
				g: parseInt(result[2], 16),
				b: parseInt(result[3], 16)
			} : null;
		}
		function animation(time) {
		if (lastTime) {
			const timePassed = time - lastTime;
			currentTime += timePassed;
			const speed = 0.008;

			const topLayer = stack[stack.length - 1];
			const previousLayer = stack[stack.length - 2];

			const boxShouldMove = !gameEnded;

			const currentAltitude = stack.length * boxHeight;

			// Update field position to match the blocks (now that it's rotated)
			field.position.set(0, -boxHeight / 2, 0); // Position it below the first block

			// Check if the texture needs to be resized
			const textureNeedsUpdate = canvas.height !== currentAltitude; // Check altitude change

			if (textureNeedsUpdate) {
			// Update texture only when altitude changes
			backgroundTexture = generateBackgroundTexture(currentAltitude);
			canvas = backgroundTexture.image; // Update canvas reference
			backgroundPlane.material.map = backgroundTexture;
			} else {
			// Update texture data directly
			backgroundTexture = generateBackgroundTexture(currentAltitude); // Update the texture
			backgroundPlane.material.map = backgroundTexture;              // Assign the updated texture
			}
			
			const context = canvas.getContext('2d');

			// Move Clouds (if visible)
			if (currentAltitude >= 5 && currentAltitude <= 15) {
				for (let i = 0; i < cloudPositions.length; i++) {
					cloudPositions[i].x += cloudPositions[i].speedX;
					
					// Reset horizontal position if the cloud moves off the screen
					if (cloudPositions[i].x > 512) {
						cloudPositions[i].x = -100 - Math.random() * 200;
					}
				}
			} else if (currentAltitude > 15) { // If above the altitude range
				for (let i = 0; i < cloudPositions.length; i++) {
					cloudPositions[i].x += cloudPositions[i].speedX; 
				}
			}
			

			backgroundTexture.needsUpdate = true; // Signal to THREE.js to update

			backgroundTexture.needsUpdate = true; // Signal to THREE.js to update
			// Always update plane position and material needsUpdate flag to match the current altitude
			backgroundPlane.position.y = currentAltitude / 2;
			backgroundPlane.material.needsUpdate = true; 
		
			// Calculate desired dimensions based on camera and altitude
			const aspectRatio = window.innerWidth / window.innerHeight;
			const cameraHeight = Math.abs(camera.top - camera.bottom); // Using absolute value to handle negative top/bottom
			const planeHeight = cameraHeight * 2 + currentAltitude; // Extend slightly beyond camera view
			const planeWidth = planeHeight * aspectRatio;

			// Update plane geometry and position
			backgroundPlane.geometry.dispose();
			backgroundPlane.geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
			backgroundPlane.position.set(0, currentAltitude / 2, -5); // Center vertically, behind objects

			// Update background texture
			const backgroundPlaneMaterial = backgroundPlane.material;
			backgroundPlaneMaterial.map = generateBackgroundTexture(currentAltitude);
			backgroundPlaneMaterial.needsUpdate = true; 
		
			// Scroll Background (if desired)
			backgroundPlane.position.y = currentAltitude / 2; // Adjust scrolling speed
		
			if (camera.position.y < boxHeight * (stack.length - 2) + 4) {
				camera.position.y += speed * timePassed;
				// Adjust camera.far if necessary to include the background plane
				camera.far = Math.max(camera.far, backgroundPlane.position.z + 1); // Adjust the value '1' as needed
			}

			if (boxShouldMove) {
			topLayer.threejs.position[topLayer.direction] += speed * timePassed;
			topLayer.cannonjs.position[topLayer.direction] += speed * timePassed;

			if (topLayer.threejs.position[topLayer.direction] > 10) {
				missedTheSpot();
			}
			}

			if (camera.position.y < boxHeight * (stack.length - 2) + 4) {
			camera.position.y += speed * timePassed;
			}

			updatePhysics(timePassed);
			renderer.render(scene, camera);

			backgroundPlane.material.needsUpdate = true; 
			renderer.render(scene, camera);

		}
		lastTime = time;
		}

		function updatePhysics(timePassed) {
		world.step(timePassed / 1000);

		overhangs.forEach((element) => {
			element.threejs.position.copy(element.cannonjs.position);
			element.threejs.quaternion.copy(element.cannonjs.quaternion);
		});
		}

		window.addEventListener("resize", () => {
		const aspect = window.innerWidth / window.innerHeight;
		const width = 10;
		const height = width / aspect;

		camera.top = height / 2;
		camera.bottom = height / -2;

		renderer.setSize(window.innerWidth, window.innerHeight);
		renderer.render(scene, camera);
		});
    </script>
    <!-- Include any other dependencies here -->
    <!-- Then include your main.js script -->
    <script type="module-shim" src="main.js"></script>
</body>
</html>